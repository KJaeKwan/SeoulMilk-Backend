package Seoul_Milk.sm_server.mock.repository;

import Seoul_Milk.sm_server.domain.member.entity.MemberEntity;
import Seoul_Milk.sm_server.domain.taxInvoice.entity.TaxInvoice;
import Seoul_Milk.sm_server.domain.taxInvoice.enums.ProcessStatus;
import Seoul_Milk.sm_server.domain.taxInvoice.repository.TaxInvoiceRepository;
import Seoul_Milk.sm_server.global.common.exception.CustomException;
import Seoul_Milk.sm_server.global.common.exception.ErrorCode;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

public class FakeTaxInvoiceRepository implements TaxInvoiceRepository {
    private final AtomicLong autoGeneratedId = new AtomicLong(0);
    private final List<TaxInvoice> data = Collections.synchronizedList(new ArrayList<>());

    @Override
    public TaxInvoice getById(Long id) {
        return data.stream()
                .filter(taxInvoice -> taxInvoice.getTaxInvoiceId().equals(id))
                .findFirst()
                .orElseThrow(() -> new CustomException(ErrorCode.TAX_INVOICE_NOT_EXIST));
    }

    @Override
    public Optional<TaxInvoice> findById(Long id) {
        return data.stream()
                .filter(taxInvoice -> taxInvoice.getTaxInvoiceId().equals(id))
                .findFirst();
    }

    @Override
    public TaxInvoice save(TaxInvoice taxInvoice) {
        if (taxInvoice.getTaxInvoiceId() == null || taxInvoice.getTaxInvoiceId() == 0) {
            TaxInvoice newTaxInvoice = TaxInvoice.builder()
                    .taxInvoiceId(autoGeneratedId.incrementAndGet())
                    .issueId(taxInvoice.getIssueId())
                    .arap(taxInvoice.getArap())
                    .processStatus(taxInvoice.getProcessStatus())
                    .ipId(taxInvoice.getIpId())
                    .suId(taxInvoice.getSuId())
                    .chargeTotal(taxInvoice.getChargeTotal())
                    .taxTotal(taxInvoice.getTaxTotal())
                    .grandTotal(taxInvoice.getGrandTotal())
                    .erDat(taxInvoice.getErDat())
                    .ipBusinessName(taxInvoice.getIpBusinessName())
                    .suBusinessName(taxInvoice.getSuBusinessName())
                    .ipName(taxInvoice.getIpName())
                    .suName(taxInvoice.getSuName())
                    .ipAddress(taxInvoice.getIpAddress())
                    .suAddress(taxInvoice.getSuAddress())
                    .ipEmail(taxInvoice.getIpEmail())
                    .suEmail(taxInvoice.getSuEmail())
                    .member(taxInvoice.getMember())
                    .file(taxInvoice.getFile())
                    .createAt(taxInvoice.getCreateAt())
                    .build();
            data.add(newTaxInvoice);
            return newTaxInvoice;
        } else {
            delete(taxInvoice.getTaxInvoiceId());
            data.add(taxInvoice);
            return taxInvoice;
        }
    }

    @Override
    public void delete(Long id) {
        data.removeIf(taxInvoice -> taxInvoice.getTaxInvoiceId().equals(id));
    }

    @Override
    public Page<TaxInvoice> searchWithFilters(String provider, String consumer, String employeeId, MemberEntity member, LocalDate startDate, LocalDate endDate, ProcessStatus processStatus, Pageable pageable) {
        LocalDate start = (startDate != null) ? startDate : LocalDate.of(2000, 1, 1);
        LocalDate end = (endDate != null) ? endDate : LocalDate.now();

        List<TaxInvoice> filtered = data.stream()
                .filter(t -> t.getMember().equals(member))
                .filter(t -> processStatus == null || t.getProcessStatus().equals(processStatus))
                .filter(t -> (provider == null || t.getIpBusinessName().contains(provider)) && (consumer == null || t.getSuBusinessName().contains(consumer)))
                .filter(t -> {
                    LocalDateTime createAt = t.getCreateAt();
                    if (createAt == null) return false;
                    LocalDate createdDate = createAt.toLocalDate();
                    return !createdDate.isBefore(start) && !createdDate.isAfter(end);
                })

                .sorted(Comparator.comparing(TaxInvoice::getCreateAt).reversed())
                .toList();

        int startIdx = (int) pageable.getOffset();
        int endIdx = Math.min(startIdx + pageable.getPageSize(), filtered.size());
        List<TaxInvoice> pagedList = filtered.subList(startIdx, endIdx);

        return new PageImpl<>(pagedList, pageable, filtered.size());
    }

    @Override
    public Optional<TaxInvoice> findByIssueId(String issueId) {
        return data.stream()
                .filter(t -> t.getIssueId().equals(issueId))
                .findFirst();
    }

    @Override
    public List<TaxInvoice> findTempInvoicesByMember(MemberEntity member) {
        return null;
    }

    @Override
    public List<TaxInvoice> findTempInvoicesByIds(List<Long> taxInvoiceIds, MemberEntity member) {
        return null;
    }

    @Override
    public List<TaxInvoice> saveAll(List<TaxInvoice> taxInvoices) {
        return taxInvoices.stream()
                .map(this::save)
                .collect(Collectors.toList());
    }

    @Override
    public List<TaxInvoice> findAllById(List<Long> taxInvoiceIdList) {
        return data.stream()
                .filter(invoice -> taxInvoiceIdList.contains(invoice.getTaxInvoiceId()))
                .toList();
    }

    @Override
    public void deleteAll(List<TaxInvoice> taxInvoices) {
        taxInvoices.forEach(taxInvoice -> delete(taxInvoice.getTaxInvoiceId()));
    }

    @Override
    public Page<TaxInvoice> searchConsumerOrProvider(String poc, String employeeId, ProcessStatus processStatus, MemberEntity member, Pageable pageable) {
        List<TaxInvoice> filtered = data.stream()
                .filter(ti -> ti.getMember().getId().equals(member.getId()))
                .filter(ti -> processStatus == null || ti.getProcessStatus().equals(processStatus))
                .filter(ti -> {
                    if (poc == null || poc.isEmpty()) return true;
                    return (ti.getIpBusinessName() != null && ti.getIpBusinessName().contains(poc)) ||
                            (ti.getSuBusinessName() != null && ti.getSuBusinessName().contains(poc));
                })
                .sorted(Comparator.comparing(TaxInvoice::getCreateAt).reversed()) // 정렬도 흉내냄
                .collect(Collectors.toList());

        int start = (int) pageable.getOffset();
        int end = Math.min(start + pageable.getPageSize(), filtered.size());
        List<TaxInvoice> paged = filtered.subList(start, end);

        return new PageImpl<>(paged, pageable, filtered.size());
    }

    @Override
    public long getProcessStatusCount(ProcessStatus processStatus, MemberEntity member) {
        // 1. member 기준 필터링
        List<TaxInvoice> memberInvoices = data.stream()
                .filter(ti -> ti.getMember().getId().equals(member.getId()))
                .sorted(Comparator.comparing(TaxInvoice::getErDat).reversed()) // 최신순 정렬
                .limit(100)
                .toList();

        // 2. processStatus 조건에 맞는 개수 세기
        return memberInvoices.stream()
                .filter(ti -> processStatus == null || ti.getProcessStatus().equals(processStatus))
                .count();
    }

    @Override
    public void deleteOld() {

    }

    @Override
    public void updateIsTemporaryToTemp(List<Long> taxInvoiceIds) {

    }

    @Override
    public boolean existsByIssueId(String issueId) {
        return false;
    }

    @Override
    public boolean isAccessYourTaxInvoice(MemberEntity memberEntity, String issueId) {
        return false;
    }

    @Override
    public boolean isAccessYourTaxInvoice(MemberEntity memberEntity, Long id) {
        return false;
    }

    @Override
    public void updateMandatoryColumns(Long targetId, String issueId, String erDat, String ipId, String suId, int chargeTotal) {

    }

    public List<TaxInvoice> findAll() {
        return data;
    }
}
